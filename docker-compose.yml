# Docker Compose Configuration for Lapwise
# This file defines how to run PostgreSQL in a Docker container

# What is docker-compose.yml?
# - A configuration file that defines multi-container Docker applications
# - Written in YAML (Yet Another Markup Language) - indentation matters!
# - Run with: docker-compose up (start) or docker-compose down (stop)

# Version of docker-compose syntax (use version 3.8+)
version: '3.8'

# Services: Each service is a container
services:
  # Service name: "postgres" (you can reference this in your app)
  postgres:
    # Image: Which PostgreSQL version to use
    # "postgres:15-alpine" means:
    #   - postgres: Official PostgreSQL image
    #   - 15: PostgreSQL version 15
    #   - alpine: Lightweight Linux distribution (smaller image size)
    image: postgres:15-alpine

    # Container name: What to call this container (shows in Docker Desktop)
    container_name: f1-analytics-db

    # Restart policy: What to do if container crashes
    # "unless-stopped" means: always restart unless you manually stop it
    # Other options: "no", "always", "on-failure"
    restart: unless-stopped

    # Environment variables: Configuration passed to PostgreSQL
    environment:
      # Default database to create on first run
      POSTGRES_DB: f1_analytics

      # Superuser username (default is "postgres" but we're being explicit)
      POSTGRES_USER: f1admin

      # Password for the superuser
      # IMPORTANT: In production, use a strong password and load from .env file!
      # For local development, this simple password is fine.
      POSTGRES_PASSWORD: f1password

      # Optional: Set timezone (PostgreSQL will store timestamps in this timezone)
      TZ: UTC

    # Ports: Map container port to host port
    # Format: "host_port:container_port"
    # PostgreSQL runs on port 5432 inside container
    # We expose it on port 5432 on your Mac (localhost:5432)
    # If port 5432 is taken on your Mac, change left number (e.g., "5433:5432")
    ports:
      - "5432:5432"

    # Volumes: Persist data outside container
    # Without this, all data is LOST when container stops!
    # Format: "host_path:container_path"
    volumes:
      # Named volume (Docker manages storage location)
      # Data is stored even if container is deleted
      # View location: docker volume inspect f1-analytics-postgres-data
      - postgres_data:/var/lib/postgresql/data

      # Optional: Custom PostgreSQL config file
      # Uncomment if you need to tune PostgreSQL settings
      # - ./postgres.conf:/etc/postgresql/postgresql.conf

    # Networks: Allow containers to communicate
    # Not needed for single container, but good practice for future expansion
    # (e.g., if you add Redis, Nginx, etc.)
    networks:
      - f1-network

    # Health check: Verify PostgreSQL is ready to accept connections
    # This prevents your FastAPI app from trying to connect before DB is ready
    healthcheck:
      # Command to check if PostgreSQL is ready
      # pg_isready: PostgreSQL utility that returns 0 if DB accepts connections
      test: ["CMD-SHELL", "pg_isready -U f1admin -d f1_analytics"]

      # How long to wait before first health check
      interval: 10s

      # How long to wait for health check to succeed
      timeout: 5s

      # How many times to retry before marking as unhealthy
      retries: 5

# Volumes: Define named volumes
volumes:
  # This creates a persistent volume for PostgreSQL data
  # Data survives container restarts/deletions
  postgres_data:
    driver: local  # Store on local disk

# Networks: Define custom networks
networks:
  # Custom network for lapwise.dev services
  # Future containers (backend, Redis, etc.) can join this network
  f1-network:
    driver: bridge  # Default network type

# ============================================================================
# How to Use This File
# ============================================================================

# Start PostgreSQL:
#   docker-compose up -d
#   (-d means "detached" - runs in background)

# Stop PostgreSQL:
#   docker-compose down
#   (Stops and removes container, but data persists in volume)

# View logs:
#   docker-compose logs postgres
#   (See what PostgreSQL is doing)

# Follow logs in real-time:
#   docker-compose logs -f postgres

# Restart PostgreSQL:
#   docker-compose restart postgres

# Remove everything including data (DANGEROUS!):
#   docker-compose down -v
#   (-v removes volumes - ALL DATA WILL BE DELETED)

# ============================================================================
# Connecting to This Database
# ============================================================================

# From your Mac (using Postico, pgAdmin, or psql):
#   Host: localhost
#   Port: 5432
#   Database: f1_analytics
#   Username: f1admin
#   Password: f1password

# From FastAPI (backend/.env):
#   DATABASE_URL=postgresql://f1admin:f1password@localhost:5432/f1_analytics

# From FastAPI running in Docker (future):
#   DATABASE_URL=postgresql://f1admin:f1password@postgres:5432/f1_analytics
#   (Use service name "postgres" instead of "localhost")

# ============================================================================
# Production Changes (When Deploying)
# ============================================================================

# 1. NEVER hardcode passwords in this file for production
#    Use environment variables:
#      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
#    Then create .env file (git-ignored):
#      POSTGRES_PASSWORD=super_secure_random_password_here

# 2. Use stronger PostgreSQL version (not alpine):
#      image: postgres:15

# 3. Consider managed PostgreSQL (AWS RDS, Google Cloud SQL, Railway)
#    instead of self-hosting in Docker

# 4. Add backup strategy:
#    - Automated backups to cloud storage
#    - Point-in-time recovery
#    - Disaster recovery plan

# 5. Tune PostgreSQL settings for production workload
#    (shared_buffers, max_connections, etc.)

# ============================================================================
# Troubleshooting
# ============================================================================

# "Port 5432 already in use":
#   - Another PostgreSQL is running on your Mac
#   - Change ports to "5433:5432" and update DATABASE_URL

# "Connection refused":
#   - Check if container is running: docker ps
#   - Check health: docker-compose ps
#   - View logs: docker-compose logs postgres

# "Data disappeared after restart":
#   - Did you run docker-compose down -v? That deletes volumes!
#   - Check volume exists: docker volume ls | grep postgres_data

# "Out of disk space":
#   - PostgreSQL data can grow large
#   - Check size: docker system df
#   - Clean old data: docker system prune
